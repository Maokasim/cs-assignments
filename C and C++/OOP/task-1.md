# Task 1: Класи та об’єкти
## Goal
Засвоїти основні поняття об’єктно-орієнтованого програмування (ООП) на прикладі мови С++

## Контент
- [Theoretical background](#Theoretical-background)
  * [Контроль доступу](#Контроль-доступу)
  * [Константні методи](#Константні-методи)
  * [Підкласи](#Підкласи)
  * [Константні методи](#Константні-методи)
  * [Віртуальні функції](#Віртуальні-функції)

- [Tasks](#Tasks)

## Theoretical background
Головна мета введення концепції класів (або структур) в С++ це забезпечення програміста засобами для створення <ins>нових типів</ins>, які були б такими ж зручними у використанні, як і вбудовані.

``Тип``  — конкретний представник деякої концепції.

``Клас`` — це тип, що визначає користувач. 

Для визначення концепції, яка не виражається безпосередньо вбудованими типами, створюються ***нові типи***. Ретельно підібраний набір типів, які визначає користувач, робить програму <ins>коротшою</ins> і <ins>виразнішою</ins>.
Основний сенс введення нових типів полягає в обмеженні доступу до даних ззовні та у використанні для цього спеціальних процедур у межах чітко визначеного інтерфейсу.

### Методи та поля 

``Поля класу`` - це змінні частіше вбудованого типу ``(int, float, char)``, або типу даних користувача, що знаходяться всередені класу.

Функції, визначені всередині опису класу називаються ``методами`` цього класу (функціями-членами), і їх можна викликати використовуючи стандартний синтаксис доступу до полів класу. 
Існує також окремий вид таких методів - геттери та сеттери, які, відповідно, займаються отриманням та налаштуванням полей класу (структури).

Визначенням ж класу є наступна конструкція:

```cpp
class A {
  int a;
  int b;
  char c;
  
  resetFields(int);
};
```

Оскільки різні класи (структури) можуть мати функції-члени з однаковими назвами, то визначаючи функцію-член за межами класу (структури) треба вказати його ім’я:

```cpp
void Date::init(int d, int m, int y) { 
  /* code */
}
```

### Контроль доступу

Розглянемо приклад:

```cpp
class X
{
  public:
    void init();
    int getITnow();
  private:
    int x,y,z;
    int px,py,pz;
};
```
Поля в закритій ``private`` частині можна використовувати тільки в межах самого класу (наприклад, у функціях-членах класу для їх зміни).

Відкрита ``public`` частина утворює відкритий інтерфейс об’єктів класу, тобто, область видимості полів класу лежить в межах усієї програми, та доступ до них є відкритий у будь-якому місці.

Також, існує мітка ``protected`` (захищений), тобто всі змінні будуть доступні тільки прямим "спадкоємцям" цього класу при наслідуванні (наступний розділ, Task 2).

Захист закритих даних базується на обмеженні використання імен членів класу. Цей захист можна обійти, маніпулюючи з адресами і явним перетворенням типу. Захист проти зловмисного доступу до закритих даних  мовою високого рівня можна забезпечити тільки на апаратному рівні, хоча навіть це — досить складне завдання в реальній системі.

Невеличка ремарка: ***треба знати, що члени класу - закриті (private) за замовчуванням, а члени структури - відкриті (public) за замовчуванням.***


### Константні методи
В мові С++ є фундаментальні типи даних які можна зробити константними, використовуючи ключове слово ``const``. Це гарантує, що всі константні змінні, яким надається певне значення - ініційовані та незмінні.

``Константний метод`` - це метод класу, який гарантує, що не буде змінювати об'єкт (його поля).

Навіщо це? Константні методи потрібні для визначення того, що можна зробити з класом ``без зміни його стану``. При цьому, користувачеві класу, наприклад, вдається уникнути зайвого копіювання об'єктів. 
Також, при правильному використанні ``const`` на рівні компіляції виключається випадкова зміна об'єкта в методі, який не повинен нічого там міняти.

Ось прикалад реалізації таких методів:

```cpp
class A
{
  int a;
  int b;
  
  public:
    int getA() const { return a; }
    int getB() const { return b; }
};
```

Спробуйте самостійно погратись з даним прикладом.

### Підкласи

``Підкласи`` — це класи, які успадковують "властивості" суперкласу ("батьківського класу"). Успадкування - є одною з трьох компонент ООП.

<p align="center">
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/multilevel-inheritance.png">
</p>

Об’єкти різних класів і самі класи можуть перебувати у відношенні ``успадкування``, за якого формується ієрархія об’єктів, що відповідає заздалегідь передбаченій ієрархії класів.
``Ієрархія класів`` дозволяє визначати нові класи на основі вже існуючих. Існуючі класи зазвичай називають ``базовими`` (інколи породжувальними), а нові класи, що формуються на основі базових, — ``похідними`` (породженими), інколи класами-нащадками або спадкоємцями. 
Похідні класи “отримують спадок” — дані і методи своїх базових класів — і, крім того, можуть поповнюватись власними компонентами (даними і власними методами).

Наприклад, за таким визначенням формується успадкування:

```cpp
class S: public X
{

};
```

Клас ``S`` породжений класом ``X``, звідки він успадковує компоненти.

### Віртуальні функції 

Віртуальні функції визначаються специфікатором ``virtual`` і дозволяють програмісту описати в базовому класі функції, які можна було б замінити у кожному наступному класі.
Тобто, у базовому класі, нехай це буде клас ``Sensor`` є метод ``.getValue()``. У нього два похідних класи ``Digital`` та ``Analog``, у яких є такий саме метод - ``.getValue()``, проте в першому одна реалізація, наприклад, зчитування та фільтраціх даних, а у другому - зовсім інша.

Так, доречі, ``virtual``-методи  - запезпечують ще одну компоненту ООП - ``поліморфізм``.

Синтаксис ``virtual``-методів наступний:
```cpp
class Base {
public:
   virtual void NameOf();   // Virtual-метод.
   void InvokingClass();    // Nonvirtual-метод.
};

// Реалізація Virtual-методу:
void Base::NameOf() {
   cout << "Base::NameOf\n";
}

// Реалізація Nonvirtual-методу:
void Base::InvokingClass() {
   cout << "Invoked by Base\n";
}

// Створення похідного класу:
class Derived : public Base {
public:
   void NameOf();          // Virtual-метод, і він має таке ж ім'я, як і в базовому!
};

// Своя реалізація для похідного класу його Virtual-методу:
void Derived::NameOf() {
   cout << "Derived::NameOf\n";
}
```

Бачите? Назва така ж сама, проте реалізація - зовсім інша :)



## Tasks:

Cтворити проект з базовим класом (та, опціонально, з класом-нащадком (нащадками)). 
Розробити реалізацію так, щоб показати:

``a`` Властивість повного наслідування усіх полів для нащадка (нащадків); 

``b`` Можливість доступу до закритої та відкритої областей класів за допомогою модифікаторів доступу;

``c`` Реалізацію static-метода, обгрунтувати чому ви його задіяли;

``d`` Властивість інкапсуляції (virtual) даних, обгрунтувати чому ви його задіяли.

Тобто, все це повинно бути у вашому класі!


### Варіанти

Завдання обираєте будь-яке. Проте, більше практики = краще засвоєння :)

``1`` Реалізувати клас ``Led``. Визначити оптимальний розмір даних для полів. Реалізувати методи для декількох режимів роботи. Адаптувати до ArduinoIDE.  

``2`` Реалізувати клас ``Buzzer``. Визначити оптимальний розмір даних для полів. Реалізувати методи для декількох режимів роботи. Адаптувати до ArduinoIDE.

``3`` Реалізувати клас інфрачервоного масиву сенсорів ``IR``. Визначити оптимальний розмір даних для полів. Реалізувати методи для декількох режимів роботи. Адаптувати до ArduinoIDE.

``4`` Реалізувати клас послідовного регiстру ``ShiftRegister``. Визначити оптимальний розмір даних для полів. Реалізувати методи для декількох режимів роботи. Адаптувати до ArduinoIDE.


У поточній директорії, у файлі ``example.cpp`` ви можете знайти приклад реалізації.
